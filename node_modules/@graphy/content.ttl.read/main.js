


const uri = require('uri-js');

const stream = require('@graphy/core.iso.stream');
const factory = require('@graphy/core.data.factory').raw;
const quad = h => factory.quad(h.subject, h.predicate, h.object, h.graph);

const RT_ESCAPES_INVALID = /(?:(?:^|[^\\])(?:\\(?:\\\\)*[^"tbnrfuU\\_~.!$&'()*+,;=/?#@%-])(?:[^\\]|$))|\\u[^A-Fa-f0-9]{4}|\\U[^A-Fa-f0-9]{8}/;
const RT_PREFIXED_NAME_NAMESPACE_VALID = /^([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}]([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}.]*[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}])?)?$/u;
const RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%])(([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}.:]|%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%])*([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}:]|%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%]))?$/u;

const RT_BLANK_NODE_VALID = /^[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_0-9]([A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}.]*[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}])?$/u;
const RT_NAMED_NODE_VALID = /^([^\0-\x20<>"{}|^`\\]|\\u[A-Fa-f0-9]{4}|\\U[A-Fa-f0-9]{8})*$/;

const RT_LITERAL_CONTENTS_VALID = /^(?:[^\\]|\\[tbnrf"'\\]|\\u[A-Fa-f0-9]{4}|\\U[A-Fa-f0-9]{8})*$/;

const R_ESCAPES = /(\\[\\])|\\([^tbnrfuU\\])/g;
const R_UNICODE_8 = /\\U([0-9A-Fa-f]{8})/g;
const R_UNICODE_ANY = /\\u([0-9A-Fa-f]{4})|\\U([0-9A-Fa-f]{8})/g;

const F_REPLACE_UNICODE_ANY = 	(s_, s_8, s_4) => String.fromCodePoint(parseInt(s_8 || s_4, 16));



const H_ESCAPES_JSON = 	{
	'\t': '\\t',
	'\u0008': '\\b',
	'\n': '\\n',
	'\r': '\\r',
	'\f': '\\f',
	'"': '\\"',
};



const R_PREFIXED_NAME_ESCAPELESS = /([^\s#@<[("':_][^\s#@<[("':]*)?:((?:[^\s#@<[("'.;,)\]\\](?:[^\s#@<[("';,)\]\\]*[^\s#@<[("'.;,)\]\\])?)?)(?:\s+|(?=\.[<[("';,)\]#\s\0]|[<[("';,)\]#]))/y;


const R_PREFIXED_NAME = /([^\s#@<[("':_][^\s#@<[("':]*)?:((?:(?:[^\s#@<[("'.;,)\]\\]|\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\s"]))(?:(?:[^\s#@<[("';,)\]\\]|\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\s"]))*(?:[^\s#@<[("'.;,)\]\\]|\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\s"])))?)?)(?:\s+|(?=\.[<[("';,)\]#\s\0]|[<[("';,)\]#]))/y;

const R_PN_LOCAL_ESCAPES = /\\(.)/g;


const R_BLANK_NODE_LABEL = /_:(.(?:[^\s:<;,)\]#]*[^\s:<.;,)\]#])?)(?:\s+|(?=[<:,;\])#]))/y;
const R_BLANK_NODE_LABEL_TERMINAL = /_:(.(?:[^\s:<;,)\]#]*[^\s:<.;,)\]#])?)(?:\s+|(?=\.?[<:,;\])#])|(?=\.[\s@#<({[}]))/y;


const R_IRIREF_ESCAPELESS = /<([^\\>]*)>\s*/y;
const R_IRIREF = /<([^>]*)>\s*/y;


const R_STRING_LITERAL_QUOTE = /"((?:[^"\\]|\\.)*)"(?:\s+|(?=[@^.,;\])#]))/y;
const R_STRING_LITERAL_QUOTE_ESCAPELESS = /"([^"\\]*)"(?:\s+|(?=[@^.,;\])#]))/y;
const R_STRING_LITERAL_SINGLE_QUOTE = /'((?:[^'\\]|\\.)*)'(?:\s+|(?=[@^.,;\])#]))/y;
const R_STRING_LITERAL_SINGLE_QUOTE_ESCAPELESS = /'([^'\\]*)'(?:\s+|(?=[@^.,;\])#]))/y;
const R_STRING_LITERAL_LONG_QUOTE = /"""((?:(?:""?)?(?:[^"\\]|\\.))*)"""\s*/y;
const R_STRING_LITERAL_LONG_SINGLE_QUOTE = /'''((?:(?:''?)?(?:[^'\\]|\\.))*)'''\s*/y;

const R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))(\.?[eE][+-]?[0-9]+)?)(?:\s+|(?=\.[^eE0-9]|[;,)\]]))/y;
const R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\s*/y;
const R_A = /a(?:\s+|(?=[[("'<#]))/y;

const R_DOUBLE_CARET = /\^\^/y;
const R_WS = /\s*/y;
const R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\s+|(?=[.,;\])#]))/y;

const R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\s*/y;
const R_PREFIX_ID = /([^#:]*):\s*/iy;
const R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\s*/y;


const R_COMMENT = /(#[^\n]*\n\s*)+/y;

const RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\-+]*:/;
const R_RELATIVE_URI = /^(\/[^?#]+)([?#].*)?$/;
const R_BASE_IRI = /^((([A-Za-z0-9.\-+]*:\/)?\/[^/>]*)?(\/(?:[^/>]*\/)*)?[^>]*)$/;

const R_ANONYMOUS_BLANK_NODE = /\[\s*\]\s*/y;
const R_CHAR_BLANK_NODE = /\[(?:\s+|(?=[^\]]))/y;
const R_CHAR_COLLECTION = /\(\s*/y;

const R_CHAR_KET = /\]\s*/y;


const R_CHAR_STOP = /\.\s*/y;

const KT_RDF_LANG_STRING = factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
const KT_RDF_TYPE = factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
const KT_RDF_FIRST = factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');
const KT_RDF_REST = factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest');
const KT_RDF_NIL = factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil');


const KT_DEFAULT_GRAPH = factory.defaultGraph();

const unescape_literal_short = s_literal => 	JSON.parse('"'
	+s_literal
		.replace(R_UNICODE_8, F_REPLACE_UNICODE_ANY)
		.replace(R_ESCAPES, '$1$2') // no need to escape anything other than reserved characters
		.replace(/[\t"\f\u0008]/g, s => H_ESCAPES_JSON[s])
				+'"');
const unescape_literal_long = s_literal => 	JSON.parse('"'
	+s_literal
		.replace(R_UNICODE_8, F_REPLACE_UNICODE_ANY)
		.replace(R_ESCAPES, '$1$2') // no need to escape anything other than reserved characters
		.replace(/[\t"\n\r\f\u0008]/g, s => H_ESCAPES_JSON[s])
				+'"');

const match_prefixed_name_escapeless = (s, i) => {
	R_PREFIXED_NAME_ESCAPELESS.lastIndex = i;
	return [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];
};

const match_prefixed_name = (s, i) => {
	R_PREFIXED_NAME.lastIndex = i;
	return [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];
};



class Turtle_Reader extends stream.Transform {
	constructor(g_impls) {
		super({
			// do not decode strings into buffers
			decodeStrings: false,

			// accept strings as input on writable side
			writableObjectMode: false,

			// output quad objects on readable side
			readableObjectMode: true,

			// implementations
			flush: g_impls.flush,
			transform: g_impls.transform,
		});
	}

	// intercept pipe
	pipe(ds_out) {
		let ds_dst = ds_out;

		// non-object mode
		if(!ds_dst._writableState.objectMode) {
			// transform to JSON
			ds_out = stream.quads_to_json();
		}
		// yet object mode and graphy writable
		else if(ds_out.isGraphyWritable) {
			// transform to writable data events
			ds_out = stream.quads_to_writable();
		}

		// interim stream created
		if(ds_out !== ds_dst) {
			// forward output to super
			super.pipe(ds_out);

			// pipe outpu to destination
			return ds_out.pipe(ds_dst);
		}
		// forward as-is to super
		else {
			return super.pipe(ds_dst);
		}
	}
}

class reader {
	constructor(g_config={}) {
		// impl-specific configs
		let {
			// input medium
			input: g_input=null,

			// a state to inherit
			state: g_state={},
		} = g_config;

		// inherit state from creator
		let {
			// index for anonymous blank node labels
			blank_node_index: i_anon=0,

			// prefix map
			prefixes: h_prefixes={},

			// blank node label map
			labels: h_labels={},
		} = g_state;


		// fields
		Object.assign(this, {
			// read index
			i: 0,

			// string buffer
			s: '',

			// string buffer length
			n: 0,

			// left-over string from previous data chunk
			pre: g_config.prepend || '',

			// debug state
			debug: g_config.debug || false,

			// current reader state
			state: this.statement,

			// map of current prefix ids => iris
			prefixes: h_prefixes,

			// reader was destroyed by an error
			destroyed: false,

			// current @base url
			base_url: '',
			base_url_scheme: '',
			base_url_root: '',
			base_url_path: '',

			// current data
			subject: null,
			predicate: KT_RDF_FIRST,
			object: null,
			graph: KT_DEFAULT_GRAPH,

			// queue of nested subject, predicate, state for blanknodes and collections
			nested: [],

			// hash to keep track of all blank node labels in use
			labels: h_labels,

			// event routing
			event: this.emit,
			data: this.emit_data,

			// for restoring the original event callback when resuming paused stream
			restore_data: this.emit_data,

			// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)
			queue_event: [],

			anonymous_blank_node: s_label => factory.blankNode(s_label, true),

			// finds the next non-conflicting blank node label
			next_label() {
				let s_label = '';
				do {
					s_label = 'g'+(i_anon++);
				} while(this.labels[s_label]);

				// claim this label, and remember that we invented it
				this.labels[s_label] = 2;

				// return the label
				return s_label;
			},

			// what to do when reach eos
			eos: null,

			// which state to go to after end of statement
			after_end_of_statement: this.post_object,

			// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160
			max_token_length: g_config.max_token_length || g_config.maxTokenLength || 2048,

			// maximum length of a string (overrides max_token_length): defaults to 64 kibibytes
			max_string_length: g_config.max_string_length || g_config.maxStringLength || 65536,
		});



		// term constructors
		Object.assign(this, g_config.validate
			? {
				blank_node(s_label) {
					// test valid blank node label
					if(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: "${s_label}"`);

											// not first time use of label
					let z_label_state = this.labels[s_label];
					if(z_label_state) {
		// label was used previously by document and has no conflict
						if(1 === z_label_state) {}  // eslint-disable-line no-empty
		// label is in use by invention, this would cause a conflict
						else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
							s_label = this.labels[s_label] = this.next_label();
						}
		// label already has a redirect mapping
						else {
			// use redirected label
							s_label = this.labels[s_label];
						}
					}
	// first time use of label
					else {
		// store label in hash so we avoid future collisions
						this.labels[s_label] = 1;
					}

					// make term
					return factory.blankNode(s_label);
				},

				named_node(s_iri) {
					if(!RT_NAMED_NODE_VALID.test(s_iri)) return this.error(`invalid IRI: "${s_iri}"`);
					return factory.namedNode(s_iri);
				},

				unescape_literal_long(s_literal) {
					if(!RT_LITERAL_CONTENTS_VALID.test(s_literal)) return this.error(`invalid escapes in long string literal: "${s_literal}"`);
					try {
						return unescape_literal_long(s_literal);
					}
					catch(e_parse) {
						return this.error(`invalid string literal: "${s_literal}"`);
					}
				},

				unescape_literal_short(s_literal) {
					if(!RT_LITERAL_CONTENTS_VALID.test(s_literal)) return this.error(`invalid escapes in short string literal: "${s_literal}"`);
					try {
						return unescape_literal_short(s_literal);
					}
					catch(e_parse) {
						return this.error(`invalid string literal: "${s_literal}"`);
					}
				},

				match_prefixed_name_escapeless(s, i) {
					let [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);
					if(m_prefixed_name_e) {
						// invalid namespace
						if(!RT_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name_e[1])) {
							this.error(`invalid prefixed name namespace: "${m_prefixed_name_e[1]}:"`);
							return;
						}
						// invalid local name
						else if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name_e[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name_e, im_prefixed_name_e];
				},

				match_prefixed_name(s, i) {
					let [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);
					if(m_prefixed_name) {
						// invalid namespace
						if(!RT_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name[1])) {
							this.error(`invalid prefixed name namespace: "${m_prefixed_name[1]}:"`);
							return;
						}
						// invalid local name
						else if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name, im_prefixed_name];
				},
			}
			: {
				// term constructors
				blank_node(s_label) {
											// not first time use of label
					let z_label_state = this.labels[s_label];
					if(z_label_state) {
		// label was used previously by document and has no conflict
						if(1 === z_label_state) {}  // eslint-disable-line no-empty
		// label is in use by invention, this would cause a conflict
						else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
							s_label = this.labels[s_label] = this.next_label();
						}
		// label already has a redirect mapping
						else {
			// use redirected label
							s_label = this.labels[s_label];
						}
					}
	// first time use of label
					else {
		// store label in hash so we avoid future collisions
						this.labels[s_label] = 1;
					}

					// make term
					return factory.blankNode(s_label);
				},

				named_node: s_iri => factory.namedNode(s_iri),

				unescape_literal_short: unescape_literal_short,

				unescape_literal_long: unescape_literal_long,

				match_prefixed_name_escapeless,

				match_prefixed_name,
			});

		// oops -- user passed string into `base`
		if('string' === typeof g_config.base) {
			throw new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\n`
				+`did you mean to use the 'base_uri' key instead?`);
		}

		// base uri
		let p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI;
		if(p_set_base_uri) {
			let m_base_iri = R_BASE_IRI.exec(p_set_base_uri);
			this.base_url = m_base_iri[1];
			this.base_url_root = m_base_iri[2] || '';
			this.base_url_scheme = m_base_iri[3] || '';
			this.base_url_path = m_base_iri[4] || '';
		}
		// not set; 'url' variant is
		else if(g_config.base_url || g_config.baseUrl || g_config.baseURL) {
			throw new Error(`invalid option: .base${g_config.base_url? '_url': g_config.baseUrl? 'Url': g_config.baseURL? 'URL': ''}; use the '.base_uri' key instead`);
		}

		// transform stream
		let ds_transform = this.transform = new Turtle_Reader({
			// on data event
			transform: (s_chunk, s_encoding, fke_chunk) => {
				// concatenate current chunk to previous chunk
				let s = this.s = this.pre + s_chunk;

				// cache chunk length
				this.n = s.length;

									// consume whitespace (and incidentally reset index)
				R_WS.lastIndex = 0;
				R_WS.exec(s);
				this.i = R_WS.lastIndex;

				// resume parsing; no errors
				if(this.safe_parse(true)) {
					// emit progress event updates
					ds_transform.emit('progress', s_chunk.length);

					// done transforming this chunk
					fke_chunk();
				}
			},

			// once there's no more data to consume, invoke eof
			flush: (fke_flush) => {
				// now that input stream has ended, clean up remainder
				try {
					this.eof(1);
				}
				// read error occurred
				catch(e_eof) {
					// destroy self and stream
					this.destroy(e_eof);

					// exit gracefully
					return;
				}

				// no errors. done flushing, close read stream
				fke_flush();
			},
		});

		// when the writable side is piped into
		ds_transform.on('pipe', (ds_input) => {
			// input stream has encoding option; ensure stream encoding is utf8
			if('function' === typeof ds_input.setEncoding) {
				ds_input.setEncoding('utf8');
			}
		});

		// new listener added
		ds_transform.on('newListener', (s_event) => {
			// comment
			if('comment' === s_event) {
				this.emit_comments = (s_captured) => {
					let a_comments = s_captured.slice(1).replace(/\n\s+$/, '').split(/\n+\s*#/g);

					for(let s_comment of a_comments) {
						ds_transform.emit('comment', s_comment);
					}
				};
			}
		});

		// bind events to transform stream
		this.bind(g_config);

		// input given
		if(g_input) {
			// input is stream
			if(g_input.stream) {
				let ds_input = g_input.stream;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_input.pipe(ds_transform);
				}, 0);
			}
			// string
			else if('string' === typeof g_input.string) {
				let s_input = g_input.string;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_transform.end(s_input, 'utf8');
				}, 0);
			}
			// invalid arg
			else {
				throw new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);
			}
		}
	}

	// begin parsing, keep applying until no more stack bail-outs
	safe_parse() {
		try {
			let f_sync = this.state();
			while('function' === typeof f_sync) {
				f_sync = f_sync.apply(this);
			}
		}
		// read error occurred
		catch(e_read) {
			// destroy self and stream
			this.destroy(e_read);

			// failure
			return false;
		}

		// okay
		return true;
	}

	emit_data(g_quad) {
		this.transform.push(g_quad);
	}

	emit(s_event, ...a_args) {
		this.transform.emit(s_event, ...a_args);
	}

	queue(s_event, ...a_args) {
		this.queue_event.push({
			event: s_event,
			args: a_args,
		});
	}

	error(s_message) {
		// bail out
		throw new Error(s_message);
	}

	// parse_error (not meant to be an event callback)
	parse_error(s_expected, b_eof=false) {
		let i = 0;
		let i_off = 0;
		let s = this.s;
		return this.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
	}

	// end of file
	eof() {
		// there are events queued
		if(this.queue_event.length) {
			let a_queue = this.queue_event;

			// drain event queue
			while(a_queue.length) {
				// remove event from front of queue
				let h_event = a_queue.shift();

				// make event callback
				this[h_event.event](h_event.data);
			}
		}

		// invalid parsing state
		if(this.statement !== this.state) {
			// append EOF char
			this.s += '\0';

			// exit "flowing" mode
			this.n = this.s.length;

			// resume parsing; no errors
			if(this.safe_parse()) {
				// eof has occurred under safe parse
				if(null === this.s) return;

				// still invalid parsing state
				if(this.statement !== this.state) {
					return this.parse_error(this.state.name, true);
				}
			}
		}

		// there are still unparsed characters
		if(this.i < this.n) {
			// consume whitespace and comments
			let s = this.s;
			let i = this.i;
				// consume whitespace (and incidentally reset index)
			R_WS.lastIndex = i;
			R_WS.exec(s);
			i = R_WS.lastIndex;
			R_COMMENT.lastIndex = i;
			let m_comment = R_COMMENT.exec(s);

			// advance beyond comment
			if(R_COMMENT.lastIndex > i) {
				this.i = i = R_COMMENT.lastIndex;
				if(this.emit_comments) this.emit_comments(m_comment[0]);
			}

			// still unparsed characters
			if(i < this.n) {
				// not EOF
				if(!(i === this.n - 1 && '\0' === s[i])) {
					// bad input; parse error
					return this.parse_error(this.state.name);
				}
			}
		}

		// make buffer's alloc eligible for gc
		this.s = null;

		// transform stream
		let ds_transform = this.transform;

		// final progress update: no additional bytes were read
		ds_transform.emit('progress', 0);

		// call end event listener
		ds_transform.emit('eof', this.prefixes);

		// close write stream (EOF-signaling)
		ds_transform.push(null);
	}



	// bind event listeners to transform stream
	bind(g_config) {
		let ds_transform = this.transform;
		if(g_config.base) ds_transform.on('base', g_config.base);
		if(g_config.prefix) ds_transform.on('prefix', g_config.prefix);
		if(g_config.comment) ds_transform.on('comment', g_config.comment);
		if(g_config.error) ds_transform.on('error', g_config.error);
		if(g_config.read) ds_transform.once('read', g_config.read);
		if(g_config.progress) ds_transform.on('progress', g_config.progress);
		if(g_config.eof) ds_transform.once('eof', g_config.eof);
		if(g_config.end) ds_transform.once('end', g_config.end);
		if(g_config.finish) ds_transform.once('finish', g_config.finish);
		if(g_config.data) ds_transform.on('data', g_config.data);
	}

	// a resume-only state to handle eos interupting ';'
	post_pair() {
		let {s, i} = this;
		let x = s[i];
		if('.' === x || ']' === x) {
				// consume whitespace (and incidentally reset index)
			R_WS.lastIndex = i+1;
			R_WS.exec(s);
			this.i = R_WS.lastIndex;
		}
		return this.pairs();
	}

	// after a blank node subject (either property-list or colleciton)
	post_blank_subject() {
		let {s, i} = this;
		if('.' === s[i]) {
				// consume whitespace (and incidentally reset index)
			R_WS.lastIndex = i+1;
			R_WS.exec(s);
			this.i = R_WS.lastIndex;

			return this.statement();
		}
		return this.pairs();
	}



	// parse state for statement
	statement() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// iriref

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_subject = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_subject) {
	// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

	// ref iri
				let s_iri = m_iriref_e_subject[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set subject
					this.subject = this.named_node(s_iri);
				}
	// relative iri
				else {
					this.subject = this.named_node(uri.resolve(this.base_url, s_iri));
				}

			// predicate-object pairs state
				return this.pairs();



			// prefixed name
			}
			else {
		// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
	// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_subject) {
		// advance index
					this.i = im_prefixed_named_e_subject;

					// check valid prefix
					let s_prefix_id = m_prefixed_named_e_subject[1] || '';

// invalid prefix
					if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

				// make subject key
					this.subject = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_subject[2]);

				// predicate-object pairs state
					return this.pairs();

			// blank node label
				}
				else {
	// prepare sticky regex index
					R_BLANK_NODE_LABEL.lastIndex = i;
		// execute regex
					let m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);

		// regex was a match
					if(m_blank_node_label_subject) {
	// advance index
						this.i = R_BLANK_NODE_LABEL.lastIndex;
				// extract label
						let s_label = m_blank_node_label_subject[1];

				// make subject key
						this.subject = this.blank_node(s_label);

				// predicate-object pairs state
						return this.pairs();

			// anonymous blank node subject
					}
					else {
	// prepare sticky regex index
						R_ANONYMOUS_BLANK_NODE.lastIndex = i;

						if(R_ANONYMOUS_BLANK_NODE.exec(s)) {
	// advance index
							this.i = R_ANONYMOUS_BLANK_NODE.lastIndex;
				// set new blank node as subject
							this.subject = this.anonymous_blank_node(this.next_label());

				// goto pairs state for inside property list
							return this.pairs();

			// anonymous blank node property list subject
						}
						else {
	// prepare sticky regex index
							R_CHAR_BLANK_NODE.lastIndex = i;

							if(R_CHAR_BLANK_NODE.exec(s)) {
	// advance index
								this.i = R_CHAR_BLANK_NODE.lastIndex;
				// enter blank node
								this.subject = this.anonymous_blank_node(this.next_label());

				// how to resume when we pop state
								this.nested.push([this.subject, this.predicate, 'post_blank_subject']);

				// goto pairs state for inside property list
								return this.pairs();

						// rdf collection
							}
							else {
	// prepare sticky regex index
								R_CHAR_COLLECTION.lastIndex = i;

								if(R_CHAR_COLLECTION.exec(s)) {
	// advance index
									this.i = R_CHAR_COLLECTION.lastIndex;
				// indicate that collection subject should emit an initial statement
									this.subject = null;

				// (don't push state, we don't have a subject yet)

				// goto collection-subject state
									return this.collection_subject();

							// prefix with interupt (e.g., a comment)
								}
								else {
	// prepare sticky regex index
									R_PREFIX_KEYWORD.lastIndex = i;
		// execute regex
									let m_prefix_keyword = R_PREFIX_KEYWORD.exec(s);

		// regex was a match
									if(m_prefix_keyword) {
	// advance index
										this.i = R_PREFIX_KEYWORD.lastIndex;
					// save whether or not to expect a full stop
										this.expecting_full_stop = !!m_prefix_keyword[1];

					// goto prefix state
										return this.prefix_id();

				// base with interupt (e.g., a comment)
									}
									else {
	// prepare sticky regex index
										R_BASE_KEYWORD.lastIndex = i;
		// execute regex
										let m_base_keyword = R_BASE_KEYWORD.exec(s);

		// regex was a match
										if(m_base_keyword) {
	// advance index
											this.i = R_BASE_KEYWORD.lastIndex;
					// save whether or not to expect a full stop
											this.expecting_full_stop = !!m_base_keyword[1];

					// goto base state
											return this.base_iri();


			// iriref
										}
										else {
	// prepare sticky regex index
											R_IRIREF.lastIndex = i;
		// execute regex
											let m_iriref_subject = R_IRIREF.exec(s);

		// regex was a match
											if(m_iriref_subject) {
	// advance index
												this.i = R_IRIREF.lastIndex;

	// ref iri
												let s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
												if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set subject
													this.subject = this.named_node(s_iri);
												}
	// relative iri
												else {
													this.subject = this.named_node(uri.resolve(this.base_url, s_iri));
												}

				// predicate-object pairs state
												return this.pairs();

			// prefixed name
											}
											else {
		// try match
												let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
	// stack bail out
												if(!aw_valid_this_match_prefixed_name) return true;
												let [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;
												if(m_prefixed_named_subject) {
		// advance index
													this.i = im_prefixed_named_subject;
					// check valid prefix
													let s_prefix_id = m_prefixed_named_subject[1] || '';

// invalid prefix
													if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

					// escape local escapes
													let s_suffix = m_prefixed_named_subject[2]
														.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
														.replace(R_PN_LOCAL_ESCAPES, '$1');

				// make subject key
													this.subject = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

				// predicate-object pairs state
													return this.pairs();


		// comment
												}
												else {
	// prepare sticky regex index
													R_COMMENT.lastIndex = i;
		// execute regex
													let m_comment = R_COMMENT.exec(s);

		// regex was a match
													if(m_comment) {
	// advance index
														i = R_COMMENT.lastIndex;
														if(this.emit_comments) this.emit_comments(m_comment[0]);
														continue;

		// not iriref, not prefixed name, not blank node label, not prefix id, not base
			// match counter: 10
													}
													else {
	// break loop to retry on next chunk if eos
														break;
													}
												} // brace #10
											} // brace #9
										} // brace #8
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('statement');
				}
			}
		}

// save state before pausing
		this.state = this.statement;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for pairs
	pairs() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// benchmarks indicate: regex for end of blank node property list faster than ch

		// iriref

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_predicate = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_predicate) {
	// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

	// ref iri
				let s_iri = m_iriref_e_predicate[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set predicate
					this.predicate = this.named_node(s_iri);
				}
	// relative iri
				else {
					this.predicate = this.named_node(uri.resolve(this.base_url, s_iri));
				}

			// object-list state
				return this.object_list();

		// prefixed name
			}
			else {
		// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
	// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_predicate, im_prefixed_named_e_predicate] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_predicate) {
		// advance index
					this.i = im_prefixed_named_e_predicate;
				// check valid prefix
					let s_prefix_id = m_prefixed_named_e_predicate[1] || '';

// invalid prefix
					if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

			// make predicate key
					this.predicate = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_predicate[2]);

			// object-list state
					return this.object_list();

		// 'a'
				}
				else {
	// prepare sticky regex index
					R_A.lastIndex = i;

					if(R_A.exec(s)) {
	// advance index
						this.i = R_A.lastIndex;
			// make predicate key
						this.predicate = KT_RDF_TYPE;

			// object-list state
						return this.object_list();

		// ']' end of blank node property list
					}
					else {
	// prepare sticky regex index
						R_CHAR_KET.lastIndex = i;

						if(R_CHAR_KET.exec(s)) {
	// advance index
							this.i = R_CHAR_KET.lastIndex;
							let s_resume_state;
							[this.subject, this.predicate, s_resume_state] = this.nested.pop();
							return this[s_resume_state]();

		// iriref
						}
						else {
	// prepare sticky regex index
							R_IRIREF.lastIndex = i;
		// execute regex
							let m_iriref_predicate = R_IRIREF.exec(s);

		// regex was a match
							if(m_iriref_predicate) {
	// advance index
								this.i = R_IRIREF.lastIndex;

	// ref iri
								let s_iri = m_iriref_predicate[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
								if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set predicate
									this.predicate = this.named_node(s_iri);
								}
	// relative iri
								else {
									this.predicate = this.named_node(uri.resolve(this.base_url, s_iri));
								}

			// object-list state
								return this.object_list();

		// prefixed name
							}
							else {
		// try match
								let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
	// stack bail out
								if(!aw_valid_this_match_prefixed_name) return true;
								let [m_prefixed_named_predicate, im_prefixed_named_predicate] = aw_valid_this_match_prefixed_name;
								if(m_prefixed_named_predicate) {
		// advance index
									this.i = im_prefixed_named_predicate;
				// check valid prefix
									let s_prefix_id = m_prefixed_named_predicate[1] || '';

// invalid prefix
									if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

				// escape local escapes
									let s_suffix = m_prefixed_named_predicate[2]
										.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
										.replace(R_PN_LOCAL_ESCAPES, '$1');

			// make predicate key
									this.predicate = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

			// object-list state
									return this.object_list();
								}
								else {
	// prepare sticky regex index
									R_COMMENT.lastIndex = i;
		// execute regex
									let m_comment = R_COMMENT.exec(s);

		// regex was a match
									if(m_comment) {
	// advance index
										i = R_COMMENT.lastIndex;
										if(this.emit_comments) this.emit_comments(m_comment[0]);
										continue;

		// not iriref, not prefixed name, not 'a'
			// match counter: 6
									}
									else {
	// break loop to retry on next chunk if eos
										break;
									}
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('pairs');
				}
			}
		}

// save state before pausing
		this.state = this.pairs;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for object_list
	object_list() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// ref char
			let x = s[i];

		// iriref

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_object) {
	// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

	// ref iri
				let s_iri = m_iriref_e_object[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set object
					this.object = this.named_node(s_iri);
				}
	// relative iri
				else {
					this.object = this.named_node(uri.resolve(this.base_url, s_iri));
				}

		// prefixed name
			}
			else {
		// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
	// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_object) {
		// advance index
					this.i = im_prefixed_named_e_object;
				// check valid prefix
					let s_prefix_id = m_prefixed_named_e_object[1] || '';

// invalid prefix
					if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

			// commit object iri from resolve prefixed name
					this.object = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_object[2]);

		// string literal
				}
				else 	if(`"` === x || `'` === x) {
					return this.string_literal();

		// numeric literal
				}
				else {
	// prepare sticky regex index
					R_NUMERIC_LITERAL.lastIndex = i;
		// execute regex
					let m_numeric_literal = R_NUMERIC_LITERAL.exec(s);

		// regex was a match
					if(m_numeric_literal) {
	// advance index
						this.i = R_NUMERIC_LITERAL.lastIndex;
				// it has exponent term, xsd:double
						if(m_numeric_literal[4]) {
							this.object = factory.double(m_numeric_literal[1]);
						}
	// contains decimal point, xsd:decimal
						else if(m_numeric_literal[2] || m_numeric_literal[3]) {
							this.object = factory.decimal(m_numeric_literal[1]);
						}
	// otherwise, it is an integer
						else {
							this.object = factory.integer(m_numeric_literal[1]);
						}

		// boolean literal
					}
					else {
	// prepare sticky regex index
						R_BOOLEAN_LITERAL.lastIndex = i;
		// execute regex
						let m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);

		// regex was a match
						if(m_boolean_literal) {
	// advance index
							this.i = R_BOOLEAN_LITERAL.lastIndex;
				// make literal
							this.object = factory.boolean(!!m_boolean_literal[1]);

		// blank node property list
						}
						else 	if(`[` === x) {
			// advance index to next token
				// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							this.i = R_WS.lastIndex;

			// make object
							let kt_blank_node = this.object = this.anonymous_blank_node(this.next_label());

			// emit statement event
							this.data(quad(this));

			// push state to stack
							this.nested.push([this.subject, this.predicate, 'post_object']);

			// set new subject
							this.subject = kt_blank_node;

			// goto parsing pairs state
							return this.pairs();

		// labeled blank node
						}
						else {
	// prepare sticky regex index
							R_BLANK_NODE_LABEL_TERMINAL.lastIndex = i;
		// execute regex
							let m_blank_node_label_object = R_BLANK_NODE_LABEL_TERMINAL.exec(s);

		// regex was a match
							if(m_blank_node_label_object) {
	// advance index
								this.i = R_BLANK_NODE_LABEL_TERMINAL.lastIndex;
			// ref blank node label
								let s_label = m_blank_node_label_object[1];

			// make object
								this.object = this.blank_node(s_label);

		// collection
							}
							else 	if(`(` === x) {
			// advance index to next token
				// consume whitespace (and incidentally reset index)
								R_WS.lastIndex = i+1;
								R_WS.exec(s);
								this.i = R_WS.lastIndex;

			// state to resume after collection ends
								this.nested.push([this.subject, this.predicate, 'post_object']);

			// goto collection-object state
								return this.collection_object();

		// iriref
							}
							else {
	// prepare sticky regex index
								R_IRIREF.lastIndex = i;
		// execute regex
								let m_iriref_object = R_IRIREF.exec(s);

		// regex was a match
								if(m_iriref_object) {
	// advance index
									this.i = R_IRIREF.lastIndex;

	// ref iri
									let s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
									if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set object
										this.object = this.named_node(s_iri);
									}
	// relative iri
									else {
										this.object = this.named_node(uri.resolve(this.base_url, s_iri));
									}

		// prefixed name
								}
								else {
		// try match
									let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
	// stack bail out
									if(!aw_valid_this_match_prefixed_name) return true;
									let [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;
									if(m_prefixed_named_object) {
		// advance index
										this.i = im_prefixed_named_object;
				// check valid prefix
										let s_prefix_id = m_prefixed_named_object[1] || '';

// invalid prefix
										if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

				// escape local escapes
										let s_suffix = m_prefixed_named_object[2]
											.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
											.replace(R_PN_LOCAL_ESCAPES, '$1');

			// commit object iri from resolve prefixed name
										this.object = this.named_node(this.prefixes[s_prefix_id] + s_suffix);
									}
									else {
	// prepare sticky regex index
										R_COMMENT.lastIndex = i;
		// execute regex
										let m_comment = R_COMMENT.exec(s);

		// regex was a match
										if(m_comment) {
	// advance index
											i = R_COMMENT.lastIndex;
											if(this.emit_comments) this.emit_comments(m_comment[0]);
											continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
			// match counter: 7
										}
										else {
	// break loop to retry on next chunk if eos
											break;
										}
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1


		// fall through for cases that did not change state on their own
			// at this point, a new statement has been parsed
			this.data(quad(this));

// goto next parsing state; bail out of stack
			return this.after_end_of_statement;
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('object_list');
				}
			}
		}

// save state before pausing
		this.state = this.object_list;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for string_literal
	string_literal() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// we know this is going to be a literal
			let h_literal = this.object = factory.literal();

		// ref character
			let x = s[i];

		// string literal quote / string literal long quote
			if(`"` === x) {
			// `"""` string literal long quote

	// prepare sticky regex index
				R_STRING_LITERAL_LONG_QUOTE.lastIndex = i;
		// execute regex
				let m_string_literal_long_quote = R_STRING_LITERAL_LONG_QUOTE.exec(s);

		// regex was a match
				if(m_string_literal_long_quote) {
	// advance index
					this.i = R_STRING_LITERAL_LONG_QUOTE.lastIndex;
					// set literal value
					h_literal.value
		= this.unescape_literal_long(m_string_literal_long_quote[1]);


			// `"` string literal quote escapeless
				}
				else {
	// prepare sticky regex index
					R_STRING_LITERAL_QUOTE_ESCAPELESS.lastIndex = i;
		// execute regex
					let m_string_literal_quote_escapeless = R_STRING_LITERAL_QUOTE_ESCAPELESS.exec(s);

		// regex was a match
					if(m_string_literal_quote_escapeless) {
	// advance index
						this.i = R_STRING_LITERAL_QUOTE_ESCAPELESS.lastIndex;
					// set literal value
						h_literal.value = 		m_string_literal_quote_escapeless[1];


			// `"` string literal quote w/ escapes
					}
					else {
	// prepare sticky regex index
						R_STRING_LITERAL_QUOTE.lastIndex = i;
		// execute regex
						let m_string_literal_quote = R_STRING_LITERAL_QUOTE.exec(s);

		// regex was a match
						if(m_string_literal_quote) {
	// advance index
							this.i = R_STRING_LITERAL_QUOTE.lastIndex;
					// set literal value
							h_literal.value
		= this.unescape_literal_short(m_string_literal_quote[1]);


			// not string long literal quote, not string literal quote
				// match counter: 2
						}
						else {
	// break loop to retry on next chunk if eos
							break;
						}
					} // brace #2
				} // brace #1


		// `'''` string literal long single quote
			}
			else {
	// prepare sticky regex index
				R_STRING_LITERAL_LONG_SINGLE_QUOTE.lastIndex = i;
		// execute regex
				let m_string_literal_long_single_quote = R_STRING_LITERAL_LONG_SINGLE_QUOTE.exec(s);

		// regex was a match
				if(m_string_literal_long_single_quote) {
	// advance index
					this.i = R_STRING_LITERAL_LONG_SINGLE_QUOTE.lastIndex;
				// set literal value
					h_literal.value
		= this.unescape_literal_long(m_string_literal_long_single_quote[1]);


		// `'` string literal quote escapeless
				}
				else {
	// prepare sticky regex index
					R_STRING_LITERAL_SINGLE_QUOTE_ESCAPELESS.lastIndex = i;
		// execute regex
					let m_string_literal_single_quote_escapeless = R_STRING_LITERAL_SINGLE_QUOTE_ESCAPELESS.exec(s);

		// regex was a match
					if(m_string_literal_single_quote_escapeless) {
	// advance index
						this.i = R_STRING_LITERAL_SINGLE_QUOTE_ESCAPELESS.lastIndex;
				// set literal value
						h_literal.value = 		m_string_literal_single_quote_escapeless[1];


		// `'` string literal single quote w/ escapes
					}
					else {
	// prepare sticky regex index
						R_STRING_LITERAL_SINGLE_QUOTE.lastIndex = i;
		// execute regex
						let m_string_literal_single_quote = R_STRING_LITERAL_SINGLE_QUOTE.exec(s);

		// regex was a match
						if(m_string_literal_single_quote) {
	// advance index
							this.i = R_STRING_LITERAL_SINGLE_QUOTE.lastIndex;
				// set literal value
							h_literal.value
		= this.unescape_literal_short(m_string_literal_single_quote[1]);


		// not string literal long single quote, not string literal single quote
			// match counter: 3
						}
						else {
	// break loop to retry on next chunk if eos
							break;
						}
					} // brace #3
				} // brace #2
			} // brace #1


		// complete literal
			return this.datatype_or_langtag();
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_string_length) {
					return this.parse_error('string_literal');
				}
			}
		}

// save state before pausing
		this.state = this.string_literal;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for datatype_or_langtag
	datatype_or_langtag() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// ref character
			let x = s[i];

		// next token indicates datatype or langtag
			if(`^` === x || `@` === x) {
			// '^^' datatype

	// prepare sticky regex index
				R_DOUBLE_CARET.lastIndex = i;

				if(R_DOUBLE_CARET.exec(s)) {
	// advance index
					this.i = R_DOUBLE_CARET.lastIndex;
					return this.datatype();

			// '@' language tag
				}
				else {
	// prepare sticky regex index
					R_LANGTAG.lastIndex = i;
		// execute regex
					let m_langtag = R_LANGTAG.exec(s);

		// regex was a match
					if(m_langtag) {
	// advance index
						this.i = R_LANGTAG.lastIndex;
				// set literal language type
						this.object.language = m_langtag[1].toLowerCase();
						this.object.datatype = KT_RDF_LANG_STRING;

			// next token definitely datatype or langtag, we are just being interrupted by eos
				// match counter: 1
					}
					else {
	// break loop to retry on next chunk if eos
						break;
					}
				} // brace #1
			}
			else {
	// prepare sticky regex index
				R_COMMENT.lastIndex = i;
		// execute regex
				let m_comment = R_COMMENT.exec(s);

		// regex was a match
				if(m_comment) {
	// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
					continue;

		// not datatype, not language tag => that's okay! those are optional
				}
			} // brace #1


		// goto end of statement state
			// at this point, a new statement has been parsed
			this.data(quad(this));

// goto next parsing state; bail out of stack
			return this.after_end_of_statement;
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('datatype_or_langtag');
				}
			}
		}

// save state before pausing
		this.state = this.datatype_or_langtag;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for datatype
	datatype() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// iriref

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_datatype = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_datatype) {
	// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;
				let p_datatype;

	// ref iri
				let s_iri = m_iriref_e_datatype[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set p_datatype
					p_datatype = s_iri;
				}
	// relative iri
				else {
					p_datatype = uri.resolve(this.base_url, s_iri);
				}

			// set literal datatype
				this.object.datatype = this.named_node(p_datatype);

		// prefixed name
			}
			else {
		// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
	// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_datatype, im_prefixed_named_e_datatype] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_datatype) {
		// advance index
					this.i = im_prefixed_named_e_datatype;
				// check valid prefix
					let s_prefix_id = m_prefixed_named_e_datatype[1] || '';

// invalid prefix
					if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

			// set literal datatype
					this.object.datatype = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_datatype[2]);

		// iriref
				}
				else {
	// prepare sticky regex index
					R_IRIREF.lastIndex = i;
		// execute regex
					let m_iriref_datatype = R_IRIREF.exec(s);

		// regex was a match
					if(m_iriref_datatype) {
	// advance index
						this.i = R_IRIREF.lastIndex;

	// ref iri
						let s_iri = m_iriref_datatype[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
						if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set object["datatype"]
							this.object.datatype = s_iri;
						}
	// relative iri
						else {
							this.object.datatype = uri.resolve(this.base_url, s_iri);
						}

		// prefixed name
					}
					else {
		// try match
						let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
	// stack bail out
						if(!aw_valid_this_match_prefixed_name) return true;
						let [m_prefixed_named_datatype, im_prefixed_named_datatype] = aw_valid_this_match_prefixed_name;
						if(m_prefixed_named_datatype) {
		// advance index
							this.i = im_prefixed_named_datatype;
				// check valid prefix
							let s_prefix_id = m_prefixed_named_datatype[1] || '';

// invalid prefix
							if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

				// escape local escapes
							let s_suffix = m_prefixed_named_datatype[2]
								.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
								.replace(R_PN_LOCAL_ESCAPES, '$1');

			// set literal datatype
							this.object.datatype = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

		// not iriref, not prefixed name
			// match counter: 3
						}
						else {
	// break loop to retry on next chunk if eos
							break;
						}
					} // brace #3
				} // brace #2
			} // brace #1


		// goto end of statement state
			// at this point, a new statement has been parsed
			this.data(quad(this));

// goto next parsing state; bail out of stack
			return this.after_end_of_statement;
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('datatype');
				}
			}
		}

// save state before pausing
		this.state = this.datatype;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for post_object
	post_object() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// benchmarks confirm: character ref faster than regexes in this context
			let x = s[i];

		// advance index to next token beyond delimiter
			// consume whitespace (and incidentally reset index)
			R_WS.lastIndex = i+1;
			R_WS.exec(s);
			this.i = R_WS.lastIndex;

		// ',' more objects
			if(`,` === x) {
				return this.object_list();

		// ';' more predicate-object pairs
			}
			else 	if(`;` === x) {
			// next token is end of outer section
				let x1 = s[this.i];
				if('.' === x1 || ']' === x1 || ';' === x1) {
				// goto post-object state
					return this.post_object();
				}
			// eos
				else if(this.i === n) {
				// go to post-pair state
					return this.post_pair();
				}
				return this.pairs();

		// '.' end of statement
			}
			else 	if(`.` === x) {
			// assert not nested
				if(this.nested.length) {
				// reset index to that character
					this.i = i;

				// emit parse error
					return this.parse_error('end_of_property_list');
				}
				return this.statement();

		// ']' end of property-object pairs
			}
			else 	if(`]` === x) {
				let s_resume_state;
				[this.subject, this.predicate, s_resume_state] = this.nested.pop();
				return this[s_resume_state]();

		// ')' end of collection
			}
			else 	if(`)` === x) {
			// should not be here
				return this.parse_error('unexpected end of collection');


		// comment
			}
			else {
	// prepare sticky regex index
				R_COMMENT.lastIndex = i;
		// execute regex
				let m_comment = R_COMMENT.exec(s);

		// regex was a match
				if(m_comment) {
	// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
					continue;

		// comment interrupted by eos?
			// match counter: 1
				}
				else {
	// break loop to retry on next chunk if eos
					break;
				}
			} // brace #1
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('post_object');
				}
			}
		}

// save state before pausing
		this.state = this.post_object;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for base_iri
	base_iri() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// prefix id

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_base = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_base) {
	// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

	// ref iri
				let s_iri = m_iriref_e_base[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set base_url
					this.base_url = s_iri;
				}
	// relative iri
				else {
					this.base_url = uri.resolve(this.base_url, s_iri);
				}		let m_base_iri = R_BASE_IRI.exec(this.base_url);
				this.base_url = m_base_iri[1];
				this.base_url_root = m_base_iri[2] || '';
				this.base_url_scheme = m_base_iri[3] || '';
				this.base_url_path = m_base_iri[4] || '';


			// emit base event
				this.emit('base', this.base_url);

				if(this.expecting_full_stop) {
	// change state
					return this.full_stop();
				}

			// goto prefix iri state
				return this.statement();

		// prefix id
			}
			else {
	// prepare sticky regex index
				R_IRIREF.lastIndex = i;
		// execute regex
				let m_iriref_base = R_IRIREF.exec(s);

		// regex was a match
				if(m_iriref_base) {
	// advance index
					this.i = R_IRIREF.lastIndex;

	// ref iri
					let s_iri = m_iriref_base[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
					if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set base_url
						this.base_url = s_iri;
					}
	// relative iri
					else {
						this.base_url = uri.resolve(this.base_url, s_iri);
					}		let m_base_iri = R_BASE_IRI.exec(this.base_url);
					this.base_url = m_base_iri[1];
					this.base_url_root = m_base_iri[2] || '';
					this.base_url_scheme = m_base_iri[3] || '';
					this.base_url_path = m_base_iri[4] || '';


			// emit base event
					this.emit('base', this.base_url);

					if(this.expecting_full_stop) {
	// change state
						return this.full_stop();
					}

			// goto prefix iri state
					return this.statement();

		// for poorly-placed comments
				}
				else {
	// prepare sticky regex index
					R_COMMENT.lastIndex = i;
		// execute regex
					let m_comment = R_COMMENT.exec(s);

		// regex was a match
					if(m_comment) {
	// advance index
						i = R_COMMENT.lastIndex;
						if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
						continue;

			// match counter: 2
					}
					else {
	// break loop to retry on next chunk if eos
						break;
					}
				} // brace #2
			} // brace #1
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('base_iri');
				}
			}
		}

// save state before pausing
		this.state = this.base_iri;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for prefix_id
	prefix_id() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// prefix id

	// prepare sticky regex index
			R_PREFIX_ID.lastIndex = i;
		// execute regex
			let m_prefix_id = R_PREFIX_ID.exec(s);

		// regex was a match
			if(m_prefix_id) {
	// advance index
				this.i = R_PREFIX_ID.lastIndex;
			// set temp prefix id
				this.temp_prefix_id = m_prefix_id[1];

			// goto prefix iri state
				return this.prefix_iri();

		// for poorly-placed comments
			}
			else {
	// prepare sticky regex index
				R_COMMENT.lastIndex = i;
		// execute regex
				let m_comment = R_COMMENT.exec(s);

		// regex was a match
				if(m_comment) {
	// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
					continue;

			// match counter: 1
				}
				else {
	// break loop to retry on next chunk if eos
					break;
				}
			} // brace #1
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('prefix_id');
				}
			}
		}

// save state before pausing
		this.state = this.prefix_id;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for prefix_iri
	prefix_iri() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
			let h_prefixes = this.prefixes;
			let s_prefix_id = this.temp_prefix_id;
			let p_prefix_iri;

		// prefix iri

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_prefix = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_prefix) {
	// advance index
				this.i = R_IRIREF_ESCAPELESS.lastIndex;

	// ref iri
				let s_iri = m_iriref_e_prefix[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set p_prefix_iri
					p_prefix_iri = s_iri;
				}
	// relative iri
				else {
					p_prefix_iri = uri.resolve(this.base_url, s_iri);
				}

			// existing mapping
				if(s_prefix_id in h_prefixes) {
				// doesn't match existing
					if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
					// emit change event
						if(this.prefix_change) {
							this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
						}

					// update prefix
						h_prefixes[s_prefix_id] = p_prefix_iri;
					}
				}
			// first mapping; set prrefix
				else {
					h_prefixes[s_prefix_id] = p_prefix_iri;
				}

			// emit prefix event
				this.event('prefix', s_prefix_id, p_prefix_iri);

				if(this.expecting_full_stop) {
	// change state
					return this.full_stop();
				}

			// goto statement state
				return this.statement();

		// prefix iri
			}
			else {
	// prepare sticky regex index
				R_IRIREF.lastIndex = i;
		// execute regex
				let m_iriref_prefix = R_IRIREF.exec(s);

		// regex was a match
				if(m_iriref_prefix) {
	// advance index
					this.i = R_IRIREF.lastIndex;

	// ref iri
					let s_iri = m_iriref_prefix[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
					if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set p_prefix_iri
						p_prefix_iri = s_iri;
					}
	// relative iri
					else {
						p_prefix_iri = uri.resolve(this.base_url, s_iri);
					}

			// existing mapping
					if(s_prefix_id in h_prefixes) {
				// doesn't match existing
						if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
					// emit change event
							if(this.prefix_change) {
								this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
							}

					// update prefix
							h_prefixes[s_prefix_id] = p_prefix_iri;
						}
					}
			// first mapping; set prrefix
					else {
						h_prefixes[s_prefix_id] = p_prefix_iri;
					}

			// emit prefix event
					this.event('prefix', s_prefix_id, p_prefix_iri);

					if(this.expecting_full_stop) {
	// change state
						return this.full_stop();
					}

			// goto statement state
					return this.statement();

		// for poorly-placed comments
				}
				else {
	// prepare sticky regex index
					R_COMMENT.lastIndex = i;
		// execute regex
					let m_comment = R_COMMENT.exec(s);

		// regex was a match
					if(m_comment) {
	// advance index
						i = R_COMMENT.lastIndex;
						if(this.emit_comments) this.emit_comments(m_comment[0]);
			// do not change state
						continue;

			// match counter: 2
					}
					else {
	// break loop to retry on next chunk if eos
						break;
					}
				} // brace #2
			} // brace #1
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('prefix_iri');
				}
			}
		}

// save state before pausing
		this.state = this.prefix_iri;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}


	// in case eos happens twice during prefix / base (extremely unlikely)


	// parse state for full_stop
	full_stop() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
	// prepare sticky regex index
			R_CHAR_STOP.lastIndex = i;

			if(R_CHAR_STOP.exec(s)) {
	// advance index
				this.i = R_CHAR_STOP.lastIndex;
			// resume statement
				return this.statement();

		// poorly-placed comment
			}
			else {
	// prepare sticky regex index
				R_COMMENT.lastIndex = i;
		// execute regex
				let m_comment = R_COMMENT.exec(s);

		// regex was a match
				if(m_comment) {
	// advance index
					i = R_COMMENT.lastIndex;
					if(this.emit_comments) this.emit_comments(m_comment[0]);
			// try again
					continue;

		// possibly interrupted by eos
			// match counter: 1
				}
				else {
	// break loop to retry on next chunk if eos
					break;
				}
			} // brace #1
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('full_stop');
				}
			}
		}

// save state before pausing
		this.state = this.full_stop;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for collection_subject
	collection_subject() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// ref char
			let x = s[i];

		// end of collection
			if(`)` === x) {
				// consume whitespace (and incidentally reset index)
				R_WS.lastIndex = i+1;
				R_WS.exec(s);
				this.i = R_WS.lastIndex;

			// no items in collection subject
				if(null === this.subject) {
				// prepare subject
					this.subject = KT_RDF_NIL;

				// state was never pushed to stack, jump to post_subject state
					return this.post_blank_subject();
				}
			// otherwise, there must be items in collection

			// commit collection end
				this.object = KT_RDF_NIL;
				this.data(quad(this));

			// restore state from stack
				let s_resume_state;
				[this.subject, this.predicate, s_resume_state] = this.nested.pop();
				return this[s_resume_state]();
			}



		// otherwise, pre-emptively secure the next blank node label
			let s_pointer_label;

		// very first collection object
			let b_pushed = false;
			if(null === this.subject) {
			// set quasi subject (really for resume state)
				s_pointer_label = this.next_label();
				this.subject = this.anonymous_blank_node(s_pointer_label);
				this.nested.push([this.subject, this.predicate, 'pairs']);
			// reset subject for later conditional branch
				this.subject = null;
				b_pushed = true;
			}

		// iriref

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_object) {
	// advance index
				i = R_IRIREF_ESCAPELESS.lastIndex;

	// ref iri
				let s_iri = m_iriref_e_object[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set object
					this.object = this.named_node(s_iri);
				}
	// relative iri
				else {
					this.object = this.named_node(uri.resolve(this.base_url, s_iri));
				}

		// prefixed name
			}
			else {
		// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
	// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_object) {
		// advance index
					i = im_prefixed_named_e_object;
				// check valid prefix
					let s_prefix_id = m_prefixed_named_e_object[1] || '';

// invalid prefix
					if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

			// commit object iri from resolve prefixed name
					this.object = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_object[2]);

		// string literal
				}
				else 	if(`"` === x || `'` === x) {
			// first item in list
					if(null === this.subject) {
						s_pointer_label = this.next_label();
						this.subject = this.anonymous_blank_node(s_pointer_label);
						this.predicate = KT_RDF_FIRST;
					}
			// not first item in list
					else {
				// make nest list item
						s_pointer_label = this.next_label();
						let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
						this.data(quad(this));

				// setup for object literal
						this.subject = kt_blank_node;
						this.predicate = KT_RDF_FIRST;
					}

			// how to resume collection subject state after object literal
					this.after_end_of_statement = function() {
						this.predicate = KT_RDF_REST;
						this.after_end_of_statement = this.post_object;
						return this.collection_subject();
					};
					return this.string_literal();

		// numeric literal
				}
				else {
	// prepare sticky regex index
					R_NUMERIC_LITERAL.lastIndex = i;
		// execute regex
					let m_numeric_literal = R_NUMERIC_LITERAL.exec(s);

		// regex was a match
					if(m_numeric_literal) {
	// advance index
						i = R_NUMERIC_LITERAL.lastIndex;
				// it has exponent term, xsd:double
						if(m_numeric_literal[4]) {
							this.object = factory.double(m_numeric_literal[1]);
						}
	// contains decimal point, xsd:decimal
						else if(m_numeric_literal[2] || m_numeric_literal[3]) {
							this.object = factory.decimal(m_numeric_literal[1]);
						}
	// otherwise, it is an integer
						else {
							this.object = factory.integer(m_numeric_literal[1]);
						}

		// boolean literal
					}
					else {
	// prepare sticky regex index
						R_BOOLEAN_LITERAL.lastIndex = i;
		// execute regex
						let m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);

		// regex was a match
						if(m_boolean_literal) {
	// advance index
							i = R_BOOLEAN_LITERAL.lastIndex;
			// make literal
							this.object = factory.boolean(!!m_boolean_literal[1]);

		// blank node property list
						}
						else 	if(`[` === x) {
			// advance index to next token
				// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							this.i = R_WS.lastIndex;

			// this blank node is just the next item in the list
							s_pointer_label = this.next_label();
							let kt_blank_node;
							if(null !== this.subject) {
								kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
								this.data(quad(this));
							}

			// subject needs to be set
							this.subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);
							this.predicate = KT_RDF_FIRST;
							let s_label = this.next_label();
							kt_blank_node = this.object = this.anonymous_blank_node(s_label);
							this.data(quad(this));

			// when resume
							this.predicate = KT_RDF_REST;

			// push state
							this.nested.push([this.subject, this.predicate, 'collection_subject']);

			// prepare next triple
							this.subject = kt_blank_node;

			// goto parsing pairs state
							return this.pairs();

		// new collection
						}
						else 	if(`(` === x) {
				// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							i = R_WS.lastIndex;

			// empty collection
							if(')' === s[i]) {
								this.i = i;
								this.subject = this.nested[this.nested.length-1][0];
								this.predicate = KT_RDF_FIRST;
								this.nested.push([
									this.subject,
									KT_RDF_REST,
									'collection_subject',
								]);
								return this.collection_object();
							}



			// commit list item pointer
							s_pointer_label = this.next_label();
							let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
							this.data(quad(this));

			// add this list as an item to the outer list
							this.subject = kt_blank_node;
							this.predicate = KT_RDF_REST;
							this.nested.push([this.subject, this.predicate, 'collection_object']);

			// prepare next triple
							this.predicate = KT_RDF_FIRST;



			// flowing
							continue;

		// labeled blank node
						}
						else {
	// prepare sticky regex index
							R_BLANK_NODE_LABEL.lastIndex = i;
		// execute regex
							let m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);

		// regex was a match
							if(m_blank_node_label_object) {
	// advance index
								i = R_BLANK_NODE_LABEL.lastIndex;
			// ref blank node label
								let s_label = m_blank_node_label_object[1];

			// make object
								this.object = this.blank_node(s_label);

		// iriref
							}
							else {
	// prepare sticky regex index
								R_IRIREF.lastIndex = i;
		// execute regex
								let m_iriref_object = R_IRIREF.exec(s);

		// regex was a match
								if(m_iriref_object) {
	// advance index
									i = R_IRIREF.lastIndex;

	// ref iri
									let s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
									if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set object
										this.object = this.named_node(s_iri);
									}
	// relative iri
									else {
										this.object = this.named_node(uri.resolve(this.base_url, s_iri));
									}

		// prefixed name
								}
								else {
		// try match
									let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
	// stack bail out
									if(!aw_valid_this_match_prefixed_name) return true;
									let [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;
									if(m_prefixed_named_object) {
		// advance index
										i = im_prefixed_named_object;
				// check valid prefix
										let s_prefix_id = m_prefixed_named_object[1] || '';

// invalid prefix
										if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

				// escape local escapes
										let s_suffix = m_prefixed_named_object[2]
											.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
											.replace(R_PN_LOCAL_ESCAPES, '$1');

			// commit object iri from resolve prefixed name
										this.object = this.named_node(this.prefixes[s_prefix_id] + s_suffix);
									}
									else {
	// prepare sticky regex index
										R_COMMENT.lastIndex = i;
		// execute regex
										let m_comment = R_COMMENT.exec(s);

		// regex was a match
										if(m_comment) {
	// advance index
											i = R_COMMENT.lastIndex;
											if(this.emit_comments) this.emit_comments(m_comment[0]);
											continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
			// match counter: 7
										}
										else {
// ran out of characters after pushing state, pop it
											if(b_pushed) this.nested.pop();

	// break loop to retry on next chunk if eos
											break;
										}
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1


			let kt_blank_node_outer;
			if(!s_pointer_label) s_pointer_label = this.next_label();

		// not the very first item of collection subject
			if(this.subject !== null) {
			// ref object
				let w_object = this.object;

			// create blanknode to embed list
				kt_blank_node_outer = this.object = this.anonymous_blank_node(s_pointer_label);

			// emit statement that functions as collection's head "pointer"
				this.data(quad(this));

			// swap back object
				this.object = w_object;
			}

		// emit statement that is item
			this.subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);
			this.predicate = KT_RDF_FIRST;
			this.data(quad(this));

		// prepare next predicate
			this.predicate = KT_RDF_REST;
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('collection_subject');
				}
			}
		}

// save state before pausing
		this.state = this.collection_subject;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}



	// parse state for collection_object
	collection_object() {
			// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
		// ref char
			let x = s[i];

		// end of collection
			if(`)` === x) {
				// consume whitespace (and incidentally reset index)
				R_WS.lastIndex = i+1;
				R_WS.exec(s);
				this.i = R_WS.lastIndex;

			// make & emit collection's tail "pointer"
				this.object = KT_RDF_NIL;
				this.data(quad(this));

			// restore previous state
				let s_resume_state;
				[this.subject, this.predicate, s_resume_state] = this.nested.pop();
				return this[s_resume_state]();
			}



		// otherwise, pre-emptively secure the next blank node label
			let s_pointer_label;

		// iriref

	// prepare sticky regex index
			R_IRIREF_ESCAPELESS.lastIndex = i;
		// execute regex
			let m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);

		// regex was a match
			if(m_iriref_e_object) {
	// advance index
				i = R_IRIREF_ESCAPELESS.lastIndex;
			// commit object iri as is

	// ref iri
				let s_iri = m_iriref_e_object[1];
// absolute iri
				if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set object
					this.object = this.named_node(s_iri);
				}
	// relative iri
				else {
					this.object = this.named_node(uri.resolve(this.base_url, s_iri));
				}

		// prefixed name
			}
			else {
		// try match
				let aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);
	// stack bail out
				if(!aw_valid_this_match_prefixed_name_escapeless) return true;
				let [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;
				if(m_prefixed_named_e_object) {
		// advance index
					i = im_prefixed_named_e_object;
				// check valid prefix
					let s_prefix_id = m_prefixed_named_e_object[1] || '';

// invalid prefix
					if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

			// commit object iri from resolve prefixed name
					this.object = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_object[2]);

		// string literal
				}
				else 	if(`"` === x || `'` === x) {
			// update index before changing states
					this.i = i;

			// create blanknode to embed list
					let kt_blank_node = this.object = this.anonymous_blank_node(this.next_label());

			// emit statement that functions as collection's head "pointer"
					this.data(quad(this));

			// prepare statement that is item
					this.subject = kt_blank_node;
					this.predicate = KT_RDF_FIRST;

					this.after_end_of_statement = function() {
						this.predicate = KT_RDF_REST;
						this.after_end_of_statement = this.post_object;
						return this.collection_object();
					};
					return this.string_literal();

		// numeric literal
				}
				else {
	// prepare sticky regex index
					R_NUMERIC_LITERAL.lastIndex = i;
		// execute regex
					let m_numeric_literal = R_NUMERIC_LITERAL.exec(s);

		// regex was a match
					if(m_numeric_literal) {
	// advance index
						i = R_NUMERIC_LITERAL.lastIndex;
				// it has exponent term, xsd:double
						if(m_numeric_literal[4]) {
							this.object = factory.double(m_numeric_literal[1]);
						}
	// contains decimal point, xsd:decimal
						else if(m_numeric_literal[2] || m_numeric_literal[3]) {
							this.object = factory.decimal(m_numeric_literal[1]);
						}
	// otherwise, it is an integer
						else {
							this.object = factory.integer(m_numeric_literal[1]);
						}

		// boolean literal
					}
					else {
	// prepare sticky regex index
						R_BOOLEAN_LITERAL.lastIndex = i;
		// execute regex
						let m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);

		// regex was a match
						if(m_boolean_literal) {
	// advance index
							i = R_BOOLEAN_LITERAL.lastIndex;
			// make literal
							this.object = factory.booelan(!!m_boolean_literal[1]);

		// blank node property list
						}
						else 	if(`[` === x) {
			// advance index to next token
				// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							this.i = R_WS.lastIndex;

			// commit head of list pointer
							let kt_blank_node = this.object = this.anonymous_blank_node(this.next_label());
							this.data(quad(this));

			// setup state to resume and push
							this.subject = kt_blank_node;
							this.predicate = KT_RDF_REST;
							this.nested.push([this.subject, this.predicate, 'collection_object']);

			// enter blank node
							this.predicate = KT_RDF_FIRST;
							kt_blank_node = this.object = this.anonymous_blank_node(this.next_label());
							this.data(quad(this));

			// prepare next triple
							this.subject = kt_blank_node;
							this.predicate = KT_RDF_FIRST;

			// goto parsing pairs state
							return this.pairs();

		// new collection
						}
						else 	if(`(` === x) {
				// consume whitespace (and incidentally reset index)
							R_WS.lastIndex = i+1;
							R_WS.exec(s);
							i = R_WS.lastIndex;

			// commit list item pointer
							s_pointer_label = this.next_label();
							let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
							if(null === this.subject) {
								let a_recent = this.nested[this.nested.length-1];
								this.subject = a_recent[0];
								this.predicate = a_recent[1];
							}
							this.data(quad(this));

			// add this list as an item to the outer list
							this.subject = kt_blank_node;
							this.predicate = KT_RDF_REST;
							this.nested.push([this.subject, this.predicate, 'collection_object']);

			// prepare next triple
							this.predicate = KT_RDF_FIRST;

			// flowing
							continue;

		// labeled blank node
						}
						else {
	// prepare sticky regex index
							R_BLANK_NODE_LABEL.lastIndex = i;
		// execute regex
							let m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);

		// regex was a match
							if(m_blank_node_label_object) {
	// advance index
								i = R_BLANK_NODE_LABEL.lastIndex;
			// ref blank node label
								let s_label = m_blank_node_label_object[1];

			// make collection pointer label first
								s_pointer_label = this.next_label();

			// make object
								this.object = this.blank_node(s_label);

		// iriref
							}
							else {
	// prepare sticky regex index
								R_IRIREF.lastIndex = i;
		// execute regex
								let m_iriref_object = R_IRIREF.exec(s);

		// regex was a match
								if(m_iriref_object) {
	// advance index
									i = R_IRIREF.lastIndex;
			// commit object iri as is

	// ref iri
									let s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);
// absolute iri
									if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set object
										this.object = this.named_node(s_iri);
									}
	// relative iri
									else {
										this.object = this.named_node(uri.resolve(this.base_url, s_iri));
									}

		// prefixed name
								}
								else {
		// try match
									let aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);
	// stack bail out
									if(!aw_valid_this_match_prefixed_name) return true;
									let [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;
									if(m_prefixed_named_object) {
		// advance index
										i = im_prefixed_named_object;
				// check valid prefix
										let s_prefix_id = m_prefixed_named_object[1] || '';

// invalid prefix
										if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);

				// escape local escapes
										let s_suffix = m_prefixed_named_object[2]
											.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
											.replace(R_PN_LOCAL_ESCAPES, '$1');

			// commit object iri from resolve prefixed name
										this.object = this.named_node(this.prefixes[s_prefix_id] + s_suffix);
									}
									else {
	// prepare sticky regex index
										R_COMMENT.lastIndex = i;
		// execute regex
										let m_comment = R_COMMENT.exec(s);

		// regex was a match
										if(m_comment) {
	// advance index
											i = R_COMMENT.lastIndex;
											if(this.emit_comments) this.emit_comments(m_comment[0]);
											continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
			// match counter: 7
										}
										else {
	// break loop to retry on next chunk if eos
											break;
										}
									} // brace #7
								} // brace #6
							} // brace #5
						} // brace #4
					} // brace #3
				} // brace #2
			} // brace #1



		// ref object
			let w_object = this.object;

		// create blanknode to embed list
			if(!s_pointer_label) s_pointer_label = this.next_label();
			let kt_blank_node_outer = this.object = this.anonymous_blank_node(s_pointer_label);

		// emit statement that functions as collection's head "pointer"
			this.data(quad(this));

		// emit statement that is item
			this.subject = kt_blank_node_outer;
			this.predicate = KT_RDF_FIRST;
			this.object = w_object;
			this.data(quad(this));

		// prepare next predicate
			this.predicate = KT_RDF_REST;
		}

// ran out of characters
	// update index value
		this.i = i;

// not yet eos
		if(i < this.n) {
	// expected token was not found
			if(0 === i) {
		// we've exceeded the maximum token length
				if(this.n > this.max_token_length) {
					return this.parse_error('collection_object');
				}
			}
		}

// save state before pausing
		this.state = this.collection_object;

// store what is unparsed
		this.pre = s.slice(i);

// if we're not parsing a stream, then this is an error
		if(this.eos) this.eos();
		return;
	}


	destroy(e_destroy) {
		this.post_pair = () => {};

		this.post_blank_subject = () => {};

		this.statement = () => {};

		this.pairs = () => {};

		this.object_list = () => {};

		this.string_literal = () => {};

		this.datatype_or_langtag = () => {};

		this.datatype = () => {};

		this.post_object = () => {};

		this.base_iri = () => {};

		this.prefix_id = () => {};

		this.prefix_iri = () => {};

		this.full_stop = () => {};

		this.collection_subject = () => {};

		this.collection_object = () => {};

		this.destroyed = true;
		this.transform.demolish(e_destroy);
	}
}

module.exports = function(...a_args) {
	let g_config = {};

		// at least one argument
	if(a_args.length) {
		let z_arg_0 = a_args[0];

	// string
		if('string' === typeof z_arg_0) {
			g_config.input = {string:z_arg_0};
		}
	// null
		else if(null === z_arg_0) {
			g_config.input = null;
		}
	// node stream
		else if('function' === typeof z_arg_0.setEncoding) {
			g_config.input = {stream:z_arg_0};
		}
	// config struct
		else if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {
			g_config = z_arg_0;

		// more args; invalid
			if(a_args.length > 1) {
				throw new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);
			}
		}
	// unknown
		else {
			throw new TypeError(`unexpected input type: ${z_arg_0}`);
		}

	// more args
		if(a_args.length > 1) {
		// copy onto struct
			Object.assign(g_config, a_args[1]);

		// more args
			if(a_args.length > 2) {
				throw new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);
			}
		}
	}

	// create reader, return transform stream
	return (new reader(g_config)).transform;
};
