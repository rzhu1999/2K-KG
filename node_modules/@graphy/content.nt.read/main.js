


const stream = require('@graphy/core.iso.stream');
const factory = require('@graphy/core.data.factory').raw;

const KT_DEFAULT_GRAPH = factory.defaultGraph();
const KT_RDFS_LANG_STRING = factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');

const H_ESCAPES_JSON = 	{
	'\t': '\\t',
	'\u0008': '\\b',
	'\n': '\\n',
	'\r': '\\r',
	'\f': '\\f',
	'"': '\\"',
};

const R_ESCAPES = /(\\[\\])|\\([^tbnrfuU\\])/g;
const R_UNICODE_8 = /\\U([0-9A-Fa-f]{8})/g;
const R_UNICODE_ANY = /\\u([0-9A-Fa-f]{4})|\\U([0-9A-Fa-f]{8})/g;

const F_REPLACE_UNICODE_ANY = 	(s_, s_8, s_4) => String.fromCodePoint(parseInt(s_8 || s_4, 16));

const R_CLEAN = /\s*(?:#[^\n]*\n\s*)*\s*/y;
const R_CLEAN_COMMENTS = /\s*(#[^\n]*\n\s*)*\s*/y;
const R_LITERAL_ESCAPELESS = /^"([^\\"]*)"(?:\^\^<([^\\>]*)>|@([^ \t.]+)|)?$/;
const R_LITERAL = /^"(.*)"(?:\^\^<(.*)>|@([^ \t.]+)|)?$/;
const RT_HAS_ESCAPES = /[\\]/;
const R_EOL = /[^\n]+\n/y;

const RT_ABSOLUTE_IRI_VALID = /^[a-z][a-z0-9+\-.]*:([^\0-\x20<>"{}|^`\\]|\\u[A-Fa-f0-9]{4}|\\U[A-Fa-f0-9]{8})*$/;
const RT_BLANK_NODE_LABEL_VALID = /^(?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_0-9])(?:(?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}.])*[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}_\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}])?$/u;
const RT_ESCAPES_INVALID = /(?:(?:^|[^\\])(?:\\(?:\\\\)*[^"tbnrfuU\\_~.!$&'()*+,;=/?#@%-])(?:[^\\]|$))|\\u[^A-Fa-f0-9]{4}|\\U[^A-Fa-f0-9]{8}/;
const RT_LITERAL_CONTENTS_VALID = /^(?:[^\\\n\r]|\\[tbnrf"'\\]|\\u[A-Fa-f0-9]{4}|\\U[A-Fa-f0-9]{8})*$/;
const RT_LANGUAGE_VALID = /^[a-z]+(-[a-z0-9]+)*$/;



const R_TRIPLE_ESCAPELESS_SP = /(?:<([^\\>]*)>|_:([^\x20\t<]+))[\x20\t]*<([^\\>]*)>[\x20\t]*(?:(<[^\\>]*)>|_:([^\x20\t<]+)|"([^"\\]*)"(?:\^\^<([^\\>]*)>|@([^\x20\t.]+)|))[\x20\t]*\.\s*(#[^\n]*\n\s*|\n\s*)+/y;
const R_TRIPLE = /(?:<([^>]*)>|_:([^\x20\t<]+))[\x20\t]*<([^>]*)>[\x20\t]*(?:(<[^>]*)>|_:([^\x20\t<]+)|"((?:[^"\\]|\\.)*)"(?:\^\^<([^>]*)>|@([^\x20\t.]+)|))[\x20\t]*\.\s*(#[^\n]*\n\s*|\n\s*)+/y;



class NTriples_Reader extends stream.Transform {
	constructor(g_impls) {
		super({
			// do not decode strings into buffers
			decodeStrings: false,

			// accept strings as input on writable side
			writableObjectMode: false,

			// output quad objects on readable side
			readableObjectMode: true,

			// implementations
			flush: g_impls.flush,
			transform: g_impls.transform,
		});

		// when the writable side is piped into
		this.on('pipe', (ds_input) => {
			// input stream has encoding option; ensure stream encoding is utf8
			if('function' === typeof ds_input.setEncoding) {
				ds_input.setEncoding('utf8');
			}
		});
	}

	// intercept pipe
	pipe(ds_out) {
		let ds_dst = ds_out;

		// non-object mode
		if(!ds_dst._writableState.objectMode) {
			// transform to JSON
			ds_out = stream.quads_to_json();
		}
		// yet object mode and graphy writable
		else if(ds_out.isGraphyWritable) {
			// transform to quad-stream
			ds_out = stream.quads_to_writable();
		}

		// interim stream created
		if(ds_out !== ds_dst) {
			// forward output to super
			super.pipe(ds_out);

			// pipe outpu to destination
			return ds_out.pipe(ds_dst);
		}
		// forward as-is to super
		else {
			return super.pipe(ds_dst);
		}
	}
}

class reader {
	constructor(g_config) {
		let {
			// input medium
			input: g_input=null,

			// validate iris
			validate: b_validate=false,

			// debug
			debug: b_debug=false,
		} = g_config;

		// fields
		Object.assign(this, {
			// string buffer, accept left-over string from previous data chunk
			s: g_config.prepend || '',

			// string buffer length
			n: 0,

			debug: b_debug,

			validate: b_validate,

			destroyed: false,
		});

		// clean regex
		let r_clean = R_CLEAN;

		// validation
		Object.assign(this, b_validate
			? {
				namedNode(s_iri) {
					if(!RT_ABSOLUTE_IRI_VALID.test(s_iri)) return this._error(`invalid absolute IRI: "${s_iri}"`);
					return factory.namedNode(s_iri);
				},

				blankNode(s_label) {
					if(!RT_BLANK_NODE_LABEL_VALID.test(s_label)) return this._error(`invalid blank node label: "${s_label}"`);
					return factory.blankNode(s_label);
				},

				literal(s_literal, b_unescape=false) {
					if(!RT_LITERAL_CONTENTS_VALID.test(s_literal)) return this._error(`invalid literal: "${s_literal}"`);
					try {
						return factory.literal(b_unescape? 	JSON.parse('"'
	+s_literal
		.replace(R_UNICODE_8, F_REPLACE_UNICODE_ANY)
		.replace(R_ESCAPES, '$1$2') // no need to escape anything other than reserved characters
		.replace(/[\t"\f\u0008]/g, s => H_ESCAPES_JSON[s])
				+'"'): s_literal);
					}
					catch(e_parse) {
						return this._error(`invalid string literal: "${s_literal}"`);
					}
				},
			}
			: {
				namedNode: factory.namedNode,

				blankNode: factory.blankNode,

				literal: (s_literal, b_unescape) => factory.literal(b_unescape? 	JSON.parse('"'
	+s_literal
		.replace(R_UNICODE_8, F_REPLACE_UNICODE_ANY)
		.replace(R_ESCAPES, '$1$2') // no need to escape anything other than reserved characters
		.replace(/[\t"\f\u0008]/g, s => H_ESCAPES_JSON[s])
				+'"'): s_literal),
			});

		// transform stream
		let ds_transform;

		// whether or not data has been received before
		let b_init = false;

		// create transform
		ds_transform = this.transform = new NTriples_Reader({
			// on data event
			transform: (s_chunk, s_encoding, fk_chunk) => {
				// first transform
				if(!b_init) {
					// notify that data will begin
					ds_transform.emit('ready');

					// do not emit 'ready' event again
					b_init = false;
				}

				// concatenate current chunk to previous chunk
				let s = this.s += s_chunk;

				// remove whitespace & comments from beginning
				r_clean.lastIndex = 0;
				let m_clean = r_clean.exec(s);
				if(this.emit_comments) {
					this.emit_comments(m_clean[1]);
				}

				// update index and prepare to match statement
				this.i = r_clean.lastIndex;

				// cache chunk length
				this.n = s.length;

				// resume parsing
				try {
					this.safe_parse(true);
				}
				// read error occurred; emit and destroy stream
				catch(e_read) {
					return ds_transform.destroy(e_read);
				}

				// emit progress event updates
				ds_transform.emit('progress', s_chunk.length);

				// done transforming this chunk
				fk_chunk();
			},

			// once there's no more data to consume, invoke eof
			flush: (fk_flush) => {
				// there is still unparsed data
				if(this.s.length) {
					// append newline to end so we can match token
					this.s += '\n';

					// parse safely
					try {
						this.safe_parse();
					}
					// read error occurred; pass to flush errback and exit method
					catch(e_read) {
						// destroying during flush means overriding push
						return ds_transform.demolish(e_read);
					}

					// still unparsed characters; pass to flush errback and exit method
					if(this.s.length) {
						return ds_transform.demolish(new Error(`parsing error occurred in state: statement\n  ${this.s.substr(0, 50)}\n  ^ starting here`));
					}
				}

				// make buffer's alloc eligible for gc
				this.s = null;

				// final progress update: no additional bytes were read
				ds_transform.emit('progress', 0);

				// call end event listener
				ds_transform.emit('eof');

				// done flushing, close read stream
				fk_flush();
			},
		});

		// data event
		this.data = g_quad => ds_transform.push(g_quad);

		// new listener added
		ds_transform.on('newListener', (s_event) => {
			// comment
			if('comment' === s_event) {
				r_clean = R_CLEAN_COMMENTS;
				this.emit_comments = (s_captured) => {
					if(!s_captured) return;
					let a_comments = s_captured.slice(1).replace(/\n\s+$/, '').split(/\n+\s*#/g);

					for(let s_comment of a_comments) {
						ds_transform.emit('comment', s_comment);
					}
				};
			}
		});

		// bind events to transform stream
		this.bind(g_config);

		// input given
		if(g_input) {
			// input is stream
			if(g_input.stream) {
				let ds_input = g_input.stream;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_input.pipe(ds_transform);
				}, 0);
			}
			// string
			else if('string' === typeof g_input.string) {
				let s_input = g_input.string;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_transform.end(s_input, 'utf8');
				}, 0);
			}
			// invalid arg
			else {
				throw new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);
			}
		}
	}

	_error(s_message) {
		this.destroyed = true;
		throw new Error(s_message);
	}



	bind(g_config) {
		let ds_transform = this.transform;
		if(g_config.error) ds_transform.on('error', g_config.error);
		if(g_config.comment) ds_transform.on('comment', g_config.comment);
		if(g_config.read) ds_transform.once('read', g_config.read);
		if(g_config.progress) ds_transform.on('progress', g_config.progress);
		if(g_config.eof) ds_transform.once('eof', g_config.eof);
		if(g_config.end) ds_transform.once('end', g_config.end);
		if(g_config.finish) ds_transform.once('finish', g_config.finish);
		if(g_config.data) ds_transform.on('data', g_config.data);
	}

	safe_parse() {
		let s = this.s;
		let n = this.n;
		let i = this.i;
		let fk_data = this.data;

					// match triples/quads
		for(;;) {
	// prepare sticky regex index
			R_TRIPLE_ESCAPELESS_SP.lastIndex = i;
		// execute regex
			let m_statement_e_sp = R_TRIPLE_ESCAPELESS_SP.exec(s);

		// regex was a match
			if(m_statement_e_sp) {
	// advance index
				i = R_TRIPLE_ESCAPELESS_SP.lastIndex;
			// prep object term
				let w_object;

// object term type is named node
				if(m_statement_e_sp[4]) {
					let p_object = m_statement_e_sp[4].slice(1);
					w_object = this.namedNode(p_object);
				}
// object term type is blank node
				else if(m_statement_e_sp[5]) {
					w_object = this.blankNode(m_statement_e_sp[5]);
				}
// object term type is literal
				else {
	// contents
					w_object = this.literal(m_statement_e_sp[6], false);

	// set datatype if present
					if(m_statement_e_sp[7]) {
						w_object.datatype = this.namedNode(m_statement_e_sp[7]);
					}
	// otherwise, set language tag if present
					else if(m_statement_e_sp[8]) {
						let s_language = w_object.language = m_statement_e_sp[8].toLowerCase();
						if(this.validate && !RT_LANGUAGE_VALID.test(s_language)) return this._error(`invalid literal language tag: ${s_language}`);
						w_object.datatype = KT_RDFS_LANG_STRING;
					}
				}

// emit data event
				fk_data(
					factory.quad(
						m_statement_e_sp[2]
							? this.blankNode(m_statement_e_sp[2])
							: this.namedNode(m_statement_e_sp[1]),
						this.namedNode(m_statement_e_sp[3]),
						w_object,
						KT_DEFAULT_GRAPH
					)
				);

// comments
				if(this.emit_comments) {
					this.emit_comments(m_statement_e_sp[9]);
				}
			}
			else {
	// prepare sticky regex index
				R_TRIPLE.lastIndex = i;
		// execute regex
				let m_statement = R_TRIPLE.exec(s);

		// regex was a match
				if(m_statement) {
	// advance index
					i = R_TRIPLE.lastIndex;
			// prep object term
					let w_object;

// object term type is named node
					if(m_statement[4]) {
						let p_object = m_statement[4].slice(1);
						w_object = this.namedNode(RT_HAS_ESCAPES.test(p_object)? p_object.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): p_object);
					}
// object term type is blank node
					else if(m_statement[5]) {
						w_object = this.blankNode(RT_HAS_ESCAPES.test(m_statement[5])? m_statement[5].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): m_statement[5]);
					}
// object term type is literal
					else {
	// contents
						w_object = this.literal(m_statement[6], true);

	// set datatype if present
						if(m_statement[7]) {
							w_object.datatype = this.namedNode(RT_HAS_ESCAPES.test(m_statement[7])? m_statement[7].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): m_statement[7]);
						}
	// otherwise, set language tag if present
						else if(m_statement[8]) {
							let s_language = w_object.language = m_statement[8].toLowerCase();
							if(this.validate && !RT_LANGUAGE_VALID.test(s_language)) return this._error(`invalid literal language tag: ${s_language}`);
							w_object.datatype = KT_RDFS_LANG_STRING;
						}
					}

// emit data event
					fk_data(
						factory.quad(
							m_statement[2]
								? this.blankNode(m_statement[2])
								: this.namedNode(RT_HAS_ESCAPES.test(m_statement[1])? m_statement[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): m_statement[1]),
							this.namedNode(RT_HAS_ESCAPES.test(m_statement[3])? m_statement[3].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): m_statement[3]),
							w_object,
							KT_DEFAULT_GRAPH
						)
					);

// comments
					if(this.emit_comments) {
						this.emit_comments(m_statement[9]);
					}
				}
				else {
	// prepare sticky regex index
					R_EOL.lastIndex = i;

					if(R_EOL.exec(s)) {
	// advance index
						this.i = R_EOL.lastIndex;
						this._error(`invalid statement:\n${this.s.substr(0, 50)}\n  ^ starting here`);

		// match counter: 2
					}
					else {
	// break loop to retry on next chunk if eos
						break;
					}
				} // brace #2
			} // brace #1
		} // end of while

// update unparsed data string
		this.s = s.substr(i);
	}
}


module.exports = function(...a_args) {
	let g_config = {};

		// at least one argument
	if(a_args.length) {
		let z_arg_0 = a_args[0];

	// string
		if('string' === typeof z_arg_0) {
			g_config.input = {string:z_arg_0};
		}
	// null
		else if(null === z_arg_0) {
			g_config.input = null;
		}
	// node stream
		else if('function' === typeof z_arg_0.setEncoding) {
			g_config.input = {stream:z_arg_0};
		}
	// config struct
		else if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {
			g_config = z_arg_0;

		// more args; invalid
			if(a_args.length > 1) {
				throw new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);
			}
		}
	// unknown
		else {
			throw new TypeError(`unexpected input type: ${z_arg_0}`);
		}

	// more args
		if(a_args.length > 1) {
		// copy onto struct
			Object.assign(g_config, a_args[1]);

		// more args
			if(a_args.length > 2) {
				throw new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);
			}
		}
	}

	// create reader, return transform stream
	return (new reader(g_config)).transform;
};
