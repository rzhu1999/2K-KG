


const factory = require('@graphy/core.data.factory');
const stream = require('@graphy/core.iso.stream');

const R_DIRECTIVE_CONTENTS = /^`\[[^\]]+\](.*)$/;

const HM_COERCIONS_DEFAULT = new Map([
	[Date, dt => factory.dateTime(dt)],
	[Number, x => factory.number(x)],
]);


class Writable extends stream.Transform {
	constructor(gc_writable={}) {
		super({
			writableObjectMode: true,
			readableObjectMode: false,
		});

		let {
			prefixes: h_prefixes={},
			collections: gc_collections=null,
		} = gc_writable;

		// start with default coercions map
		let hm_coercions = HM_COERCIONS_DEFAULT;

		// user is overriding coercions
		if(gc_writable.coercions) {
			// copy default map
			hm_coercions = new Map(hm_coercions);

			// add each entry from user-defined map
			for(let [dc_type, f_transform] of gc_writable.coercions) {
				hm_coercions.set(dc_type, f_transform);
			}
		}

		// collections
		let g_collections = {
			first: '>http://www.w3.org/1999/02/22-rdf-syntax-ns#first',
			rest: '>http://www.w3.org/1999/02/22-rdf-syntax-ns#rest',
			nil: '>http://www.w3.org/1999/02/22-rdf-syntax-ns#nil',
		};

		// custom transcoder
		if(gc_collections) {
			let {
				first: sc1_first=null,
				rest: sc1_rest=null,
				nil: sc1_nil=null,
			} = gc_collections;

			if(sc1_first) g_collections.first = sc1_first;
			if(sc1_rest) g_collections.rest = sc1_rest;
			if(sc1_nil) g_collections.nil = sc1_nil;
		}

		Object.assign(this, {
			isGraphyWritable: true,
			state: 0,
			prefixes: h_prefixes || {},
			coercions: hm_coercions,
			collections: g_collections,
		});

		// one new sources
		this.on('pipe', (ds_src) => {
			// listen for prefix events
			ds_src.on('prefix', (s_prefix_id, p_iri) => {
				this.write({
					type: 'prefixes',
					value: {
						[s_prefix_id]: p_iri,
					},
				});
			});

			// listen for comment events
			ds_src.on('comment', (s_comment) => {
				this.write({
					type: 'c3',
					value: {
						[factory.comment()]: s_comment,
					},
				});
			});
		});

		// bind event listeners
		if(gc_writable.close) this.once('close', gc_writable.close);
		if(gc_writable.drain) this.on('drain', gc_writable.drain);
		if(gc_writable.error) this.on('error', gc_writable.error);
		if(gc_writable.finish) this.once('finish', gc_writable.finish);
		if(gc_writable.data) this.on('data', gc_writable.data);
		if(gc_writable.end) this.once('end', gc_writable.end);
		if(gc_writable.warning) this.on('warning', gc_writable.warning);
	}

	// overrideable no-ops
	serialize_prefixes() {}  // eslint-disable-line class-methods-use-this

	// serialize comment
	serialize_comment(s_comment) {
		let s_write = '';

		// non-data state
		if(2 !== this.state) {
			// break line
			s_write += '\n';

			// update state
			this.state = 2;
		}

		// each line of comment
		for(let s_line of s_comment.split(/\n/g)) {
			s_write += `# ${s_line}\n`;
		}

		return s_write;
	}

	// serialize newlines
	serialize_newlines(n_newlines) {  // eslint-disable-line class-methods-use-this
		// no need to check/change state
		return '\n'.repeat(n_newlines);
	}

	// transcode collection into concise-pairs hash
	transcode_collection(a_collection) {
		let g_collections = this.collections;

		// empty collection
		if(!a_collection.length) {
			return g_collections.nil;
			// return {
			// 	[g_collections.first]: g_collections.nil,
			// };
		}
		// non-empty collection
		else {
			let z_item = a_collection[0];
			let w_first = z_item;

			// item is nested collection; transcode
			if(Array.isArray(z_item)) {
				w_first = this.transcode_collection(z_item);  // eslint-disable-line no-invalid-this
			}

			return {
				// first item
				[g_collections.first]: w_first,

				// rest of items
				[g_collections.rest]: 1 === a_collection.length
					? g_collections.nil
					: this.transcode_collection(a_collection.slice(1)),  // eslint-disable-line no-invalid-this
			};
		}
	}

	// implement stream.Transform
	_transform(g_event, s_encoding, fke_transform) {
		// try to serialize input value
		try {
			// this.push(this.data_event(g_event), 'utf8');
			fke_transform(null, this.data_event(g_event));
		}
		// serialization error
		catch(e_serialize) {
			fke_transform(e_serialize);
		}
	}

	// route writable data events
	data_event(g_event) {
		let {
			type: s_type,
			value: z_value,
		} = g_event;

		// method id
		let s_method = 'serialize_'+s_type;

		// event type exists
		if('function' === typeof this[s_method]) {
			return this[s_method](z_value);
		}
		// no such event type
		else {
			throw new Error(`no such writable data event type for RDF stream: '${s_type}'`);
		}
	}

	// serialize 'array' writable data event
	serialize_array(a_events) {
		return a_events.map(g_event => this.data_event(g_event)).join('');
	}

	// serialize a writable data event directive
	directive(sct_directive, w_value) {
		// directive contents
		let m_directive = R_DIRECTIVE_CONTENTS.exec(sct_directive);
		if(!m_directive) {
			throw new Error(`Invalid writable data event directive string: "${sct_directive}"`);
		}

		// parse as JSON
		let g_directive;
		try {
			g_directive = JSON.parse(m_directive[1]);
		}
		catch(e_parse) {
			throw new Error(`Unable to parse JSON in writable data event directive: "${m_directive[1]}"`);
		}

		// directive type
		let s_type = g_directive.type;

		// deduce directive type
		switch(s_type) {
			// comment
			case 'comment': {
				// serializer supports commenting; serialize comment
				if(this.serialize_comment) {
					return this.serialize_comment(w_value+'', g_directive);
				}
				break;
			}

			// newlines
			case 'newlines': {
				// serializer supports newlines; serialize newlines
				if(this.serialize_newlines) {
					return this.serialize_newlines(w_value);
				}
				break;
			}

			// other
			default: {
				throw new Error(`Invalid writable data event directive type: '${s_type}'`);
			}
		}

		// nothing
		return '';
	}

	// if not overriden by subclass, serialize quads in default graph
	serialize_c4(hc4_quads) {
		let h_prefixes = this.prefixes;
		let a_unions = [];
		let s_write = '';

		// each graph in quads hash
		for(let sv1_graph in hc4_quads) {
			// non-default graph; union from dataset
			if('*' !== sv1_graph) a_unions.push(sv1_graph);

			// add all quads from graph
			s_write += this.serialize_c3(hc4_quads[sv1_graph]);
		}

		// a union was performed
		if(a_unions.length) {
			// warn about implicit union
			let s_warning = `Destination format does not support quads; an implicit union into the default graph was performed on the quads contained in graphs: ${a_unions.map(sc1 => factory.c1(sc1, h_prefixes).verbose()).join(', ')}`;

			// emit warning, wasn't listened to; force thru warn/stderr channel
			if(!this.emit('warning', s_warning)) {
				console.warn(s_warning);
			}
		}

		return s_write;
	}
}

module.exports = Writable;
