


const factory = require('@graphy/core.data.factory');
const writable = require('@graphy/core.class.writable');

const N_MAX_STRING_BUFFER = 1 << 12;

class NTriples_Writer extends writable {
	constructor(gc_writer={}) {
		super(gc_writer);

		let {
			prefixes: h_prefixes={},
			indent: s_indent='\t',
			tokens: gc_tokens=null,
		} = gc_writer;

		Object.assign(this, {
			indent: s_indent,
			state: 2,
		});
	}



		// serialize c3 hash
	serialize_c3(hc3_triples) {
		let {
			prefixes: h_prefixes,
		} = this;
		let s_write = '';

			// post component
		let st_post = ' .\n';

			// each subject
		for(let sc1_subject in hc3_triples) {
				// directive; serialize it
			if('`' === sc1_subject[0]) {
				s_write += this.directive(sc1_subject, hc3_triples[sc1_subject]);
				continue;
			}
			// subject-pre component
			let st_pre = factory.c1(sc1_subject, h_prefixes).verbose()+' ';
			// pair indent & terminator
			let s_indent_pairs = '';
			let s_term_pairs = '';
			// ref pairs
			let hc2_pairs = hc3_triples[sc1_subject];
			// each predicate
			for(let sc1_predicate in hc2_pairs) {
					// directive; serialize it
				if('`' === sc1_predicate[0]) {
					s_write += this.directive(sc1_predicate, hc2_pairs[sc1_predicate]);
					continue;
				}
				// predicate component
				let st_predicate = factory.c1(sc1_predicate, h_prefixes).verbose();
				// ref objects
				let z_objects = hc2_pairs[sc1_predicate];
				// serialize objects
				s_write += this.objects(st_pre+st_predicate+' ', z_objects, st_post);
				// // string buffer became too large
					// if(s_write.length >= N_MAX_STRING_BUFFER) {
					// 	debugger;
					// }
			}
		}

		return s_write;
	}



	// write objects
	objects(s_pre, z_objects, s_post, n_nest_level=1) {
		let {
			prefixes: h_prefixes,
			coercions: hm_coercions,
		} = this;

		// deduce object value type
		switch(typeof z_objects) {
			// concise-term string
			case 'string': return s_pre+factory.c1(z_objects, h_prefixes).verbose()+s_post;

			// numeric type
			case 'number': return s_pre+factory.number(z_objects).verbose()+s_post;

			// boolean type
			case 'boolean': return s_pre+factory.boolean(z_objects).verbose()+s_post;

			// object
			case 'object': {
				// null; reject
				if(null === z_objects) throw new Error('Refusing to serialize null value given as an object of quad');

				// array, list of objects
				if(Array.isArray(z_objects) || z_objects instanceof Set) {
					let s_write = '';

					// each object
					for(let z_item of z_objects) {
						// item is an array; write RDF collection
						if(Array.isArray(z_item)) {
							// transcode collection
							let hc2_collection = this.transcode_collection(z_item);

							// serialize transcoded collection
							s_write += this.objects(s_pre, hc2_collection, s_post, n_nest_level);
						}
						// non-array; recurse on item
						else {
							s_write += this.objects(s_pre, z_item, s_post, n_nest_level);
						}
					}

					return s_write;
				}
				// plain object, blank node
				else if(Object === z_objects.constructor) {
					// new blank node
					let st_blank = factory.blankNode();

					// start with incoming triple
					let s_write = s_pre+st_blank+s_post;

					// each pair
					for(let sc1_predicate in z_objects) {
						// directive; serialize it
						if('`' === sc1_predicate[0]) {
							s_write += this.directive(sc1_predicate, z_objects[sc1_predicate]);
							continue;
						}

						// pre-string for nested triples
						let s_pre_nest = st_blank+' '+factory.c1(sc1_predicate, h_prefixes).verbose()+' ';

						// recurse
						s_write += this.objects(s_pre_nest, z_objects[sc1_predicate], s_post, n_nest_level+1);
					}

					return s_write;
				}
				// coercable instance
				else if(hm_coercions.has(z_objects.constructor)) {
					// convert javascript object to term object
					let kt_converted = hm_coercions.get(z_objects.constructor).apply(this, [z_objects, n_nest_level]);

					// serialize
					return s_pre+kt_converted.verbose(h_prefixes)+s_post;
				}
				// graphy term
				else if(z_objects.isGraphyTerm) {
					return s_pre+z_objects.verbose()+s_post;
				}
				// RDFJS term
				else if(z_objects.termType) {
					return s_pre+factory.from.term(z_objects).verbose()+s_post;
				}
			}

			// fallthrough: other
			default: {
				throw new Error(`Bad type for RDF object: [${typeof z_objects}] ${z_objects? z_objects.constructor: z_objects}`);
			}
		}
	}

	// rdfjs quad
	serialize_quad(g_quad) {
		let kq_quad = factory.from.quad(g_quad);

		// serialize quad
		let s_write = (2 !== this.state? '\n': '')
			+kq_quad.subject.verbose()
			+' '+kq_quad.predicate.verbose()
			+' '+kq_quad.object.verbose()

			+' .\n';

		// update state
		this.state = 2;

		return s_write;
	}
}

module.exports = function(gc_writer) {
	return new NTriples_Writer(gc_writer);
};
